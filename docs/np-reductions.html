<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CSC373</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <link rel="stylesheet" href="https://unpkg.com/tachyons@4.6.1/css/tachyons.min.css" type="text/css" media="screen" charset="utf-8">
        <link rel="stylesheet" href="css/main.css">
              <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" /><script type="text/javascript">window.onload = function(){var mathElements = document.getElementsByClassName("math");
      for (var i=0; i < mathElements.length; i++)
      {
       var texText = mathElements[i].firstChild
       katex.render(texText.data, mathElements[i])
      }}
      </script>
          </head>
  <body>
    <div class="ml4 mt3 pr4 ">
      <header class="w6">
        <div class="w-80-m w-100-ns bb bw2 pb1">
          <span class="f1 baskerville">isthisnagee</span>
        </div>
        <nav class="pv2 f5">
          <ul class="list pl0 pt0">
            <li class="dib">
              <a class="link pointer color-a bb pb0 bw2 space-mono b--gray" href="http://isthisnagee.github.io">isthisnagee</a><span class="f5 space-mono">&nbsp;||&nbsp;</span>
            </li>
            <li class="dib">
              <a class="pointer bb pb0 bw2 link color-a space-mono b--gray" href="index.html">csc373
              </a>
            </li>
          </ul>
        </nav>
              </header>
            <ul>
      <li><a href="#np-complete-problems">NP-complete problems:</a><ul>
      <li><a href="#a-list-of-np-complete-problems">A List of NP-complete problems</a></li>
      <li><a href="#defintions">Defintions</a><ul>
      <li><a href="#p">P</a></li>
      <li><a href="#np">NP</a></li>
      <li><a href="#np-complete">NP-Complete</a></li>
      </ul></li>
      <li><a href="#showing-that-problems-are-npc">Showing that problems are NPC</a><ul>
      <li><a href="#decision-problems-vs-optimization-problems">1. Decision problems vs optimization problems</a></li>
      <li><a href="#reductions">2. Reductions</a></li>
      </ul></li>
      <li><a href="#vertex-covers">Vertex Covers</a><ul>
      <li><a href="#hamiltonian-path-and-cycle">Hamiltonian Path and Cycle</a></li>
      </ul></li>
      <li><a href="#subset-sum">Subset Sum</a><ul>
      <li><a href="#subset-sum-is-np-complete">Subset Sum is NP complete</a></li>
      </ul></li>
      <li><a href="#knapsack">Knapsack</a></li>
      </ul></li>
      </ul>
            <h1 id="np-complete-problems">NP-complete problems:</h1>
<h2 id="a-list-of-np-complete-problems">A List of NP-complete problems</h2>
<ul>
<li>Shortest vs longest simple paths: Shortest path can be found in <span class="math inline">O(VE)</span>, but the longest simple path is NP-complete.</li>
<li>Euler tour vs hamiltonian cycle: An <strong>Euler tour</strong> of a connected, directed graph is a cycle that traverses each <em>edge</em> once, we can solve in <span class="math inline">O(E)</span> a hamiltonian cycle is a simple cycle that visits each <em>vertex</em> exactly once. Determining if a graph has a hamiltonian cyle is NP-complete.</li>
<li>2-CNF vs 3-CNF satisfiability: 2-CNF can be solved in polynomial time, but 3-CNF is np complete.</li>
</ul>
<h2 id="defintions">Defintions</h2>
<h3 id="p">P</h3>
<p>These are problems that can be solved in <span class="math inline">O(n^k)</span> for some constant <span class="math inline">k</span>, where <span class="math inline">n</span> is the size of the input problem.</p>
<h3 id="np">NP</h3>
<p>These are the set of problems that are verifiable in polynomial time. So if we are given a <em>certificate</em> of a solution, then we can verify that the certificate is correct in polynomial time of input size.</p>
<h3 id="np-complete">NP-Complete</h3>
<p>A problem is in the class NPC if it is in NP and it is as &quot;hard&quot; as any problem in NP.</p>
<blockquote>
<p>If <em>any</em> NP-complete problem can be solved in polynomial time, then every problem in NP has a polynomial time algorithm.</p>
</blockquote>
<h2 id="showing-that-problems-are-npc">Showing that problems are NPC</h2>
<p>We rely on three key concepts:</p>
<h3 id="decision-problems-vs-optimization-problems">1. Decision problems vs optimization problems</h3>
<p>We can relate an optimization problem to a decision problem by adding a bound <span class="math inline">b</span> and asking if we can do better than <span class="math inline">b</span>.</p>
<h3 id="reductions">2. Reductions</h3>
<p>Consider a decision problem <span class="math inline">A</span>, which we would like to solve in polynomial time. Suppose we know how to solve a decision problem <span class="math inline">B</span> in polynomial time. And suppose we have a procedure that transforms any instance <span class="math inline">\alpha</span> of <span class="math inline">A</span> into an instance <span class="math inline">\beta</span> of <span class="math inline">B</span> such that:</p>
<ul>
<li>The transformation takes polynomial time</li>
<li>The answers are the same. The answer for <span class="math inline">\alpha</span> is yes iff the answer for <span class="math inline">\beta</span> is yes.</li>
</ul>
<h2 id="vertex-covers">Vertex Covers</h2>
<p>Let <span class="math inline">G=(V,E)</span> be an undirected graph. <span class="math inline">S \subset V</span> is a vertex cover if every edge <span class="math inline">e \in E</span> is incident on at least one node in <span class="math inline">S</span>, and <span class="math inline">|S| = k</span>, then we call it a <span class="math inline">k</span>-cover.</p>
<p>The language is as follows: <span class="math inline">L_{VC} = \{ &lt;G,k&gt; | G</span> has a <span class="math inline">k</span>-cover <span class="math inline">\}</span>.</p>
<p>We claim <span class="math inline">L_{VC}</span> is NP-complete.</p>
<h4 id="proof">Proof</h4>
<ol type="1">
<li>[ 1 ] Certificate set <span class="math inline">S \subset V(G)</span>. Verifier checks <span class="math inline">|S|=k</span> and that every edge is incident on a vertex in <span class="math inline">S</span>. Clearly the certificate is of polynomial size and the verifier runs in polynomial time.</li>
<li>[ 2 ] We'll show that <span class="math inline">L_{CLIQUE} \leq_p L_{VC}</span> Given <span class="math inline">G</span>, <span class="math inline">k</span>, we need to construct <span class="math inline">G&#39;</span> and <span class="math inline">k&#39;</span> such that <span class="math inline">G</span> has a <span class="math inline">k</span>-clique iff <span class="math inline">G&#39;</span> has a <span class="math inline">k-</span>cover. Let <span class="math inline">V&#39; = V</span>, <span class="math inline">E&#39;</span> be <span class="math inline">(v 2) - E</span>, and <span class="math inline">k&#39; = n-k</span>. Then <span class="math inline">G</span> has a <span class="math inline">k-</span>clique S, then we need to show <span class="math inline">V - S</span> is a vertex cover in <span class="math inline">G&#39;</span>. <span class="math inline">\{u,v\} \in E&#39;</span> iff ${ u,v } E u S v S $. Let <span class="math inline">G&#39;</span> have <span class="math inline">(n-k)</span>-cover_</li>
</ol>
<p>## Hamiltonian Cycles</p>
<p>A Hamiltonian cycle is a simple cycle that goes through every vertex.</p>
<p>Fact: The language of hamiltonian cycles <span class="math inline">\{ &lt;G&gt; | G</span> has a hamiltonian cycle <span class="math inline">\} \in NPC</span>.</p>
<h3 id="hamiltonian-path-and-cycle">Hamiltonian Path and Cycle</h3>
<p>We'll show that a hamiltonian path reduces to hamiltonian cycles. Let <span class="math inline">G=(V,E)</span> be given, and we want to construct <span class="math inline">G&#39;</span> such that if <span class="math inline">G</span> has a hamiltonian cycle, then <span class="math inline">G&#39;</span> has a hamiltonian path.</p>
<p>Pick an arbitrary <span class="math inline">v \in V</span>, and split it into <span class="math inline">v, v&#39;</span>, where the neighbors of <span class="math inline">v</span> are the neighbors or <span class="math inline">v&#39;</span> , and <span class="math inline">v</span> is not connected to <span class="math inline">v&#39;</span> via an edge. We introduce to new noes <span class="math inline">f,s</span> and connect <span class="math inline">f</span> to <span class="math inline">v</span> and <span class="math inline">s</span> to <span class="math inline">v&#39;</span></p>
<pre><code>
          s  - v&#39;  -
   /               \ \
v  -  =&gt;          /
   \      f  - v  -
                   \</code></pre>
<h4 id="proof-1">Proof</h4>
<ul>
<li><a href="#section">=&gt;</a> Given a hamiltonian cycle, add <span class="math inline">f, v&#39;</span> to the beginning and <span class="math inline">v&#39;,s</span> to the end, and this is a hamiltonian path. <span class="math display">\displaystyle ( v,u_i, v ) =&gt; ( f,v,u_i, v&#39;, s ) </span></li>
</ul>
<p>Let's show that the hamiltonian cycle reduces to TSP. Given <span class="math inline">G=(V,E)</span>, undirected, we need to create <span class="math inline">G&#39;,c,k</span>.</p>
<p>Let <span class="math inline">G&#39;</span> be a complete graph on <span class="math inline">V</span> and the cost of an edge in <span class="math inline">E&#39;</span> is 0 if it's in <span class="math inline">E</span>, and 1 otherwise. Then <span class="math inline">G&#39;,c</span> has a tour of cost o if and only if <span class="math inline">G</span> has a hamiltonian cycle, ad the construction is in polynomial time.</p>
<h2 id="subset-sum">Subset Sum</h2>
<h4 id="input">Input</h4>
<ul>
<li><span class="math inline">A = \{a_1, ... , a_n \} \subseteq \mathbb Z_{&gt; 0}</span></li>
<li><span class="math inline">t \in \mathbb Z_{&gt; 0}</span></li>
</ul>
<h4 id="output">Output</h4>
<ul>
<li>1 if there exists a subset such that its sum is <span class="math inline">t</span>.</li>
<li>0 otherwise</li>
</ul>
<h3 id="subset-sum-is-np-complete">Subset Sum is NP complete</h3>
<p>Let <span class="math display">\displaystyle 
L_{SUB-SUM} = \{[ A=\{a_i\}, t ], \exists S \subseteq A \sum_{i \in S} a_i =
t\}
</span></p>
<p>We claim that the language is NPC.</p>
<h4 id="proof-2">Proof</h4>
<ol type="1">
<li>The certificate is <span class="math inline">S</span>. clearly a check of the certificate runs in polynomial time.</li>
<li><span class="math inline">L_{3-SAT} \leq_p L_{SUB-SUM}</span> Given <span class="math inline">\phi</span>, a 3-CNF over variables <span class="math inline">x_i</span> and has clauses <span class="math inline">C_j</span>, we want to construct in polynomial time <span class="math inline">A \subseteq Z_{&gt; 0}</span> such that <span class="math inline">\phi</span> is SAT if and only if <span class="math inline">(A,t) \in L_{SUB-SUM}</span></li>
</ol>
<p>Let's do 2:</p>
<p>For each variable <span class="math inline">x_i</span>, let's introduce two integers <span class="math inline">v_i</span> and <span class="math inline">v_i&#39;</span> with the following properties</p>
<ul>
<li><span class="math inline">v_i</span> has 1 at position <span class="math inline">x_i</span> in the variable part and at position <span class="math inline">C_i</span> for each <span class="math inline">C_i</span> satisfied by <span class="math inline">x_i = T</span>.</li>
<li><span class="math inline">v_i&#39;</span> has 1 at position <span class="math inline">x_i</span> in the variable part and at position <span class="math inline">C_i</span> for each <span class="math inline">C_i</span> satisfied by <span class="math inline">x_i = F</span>.</li>
</ul>
<p>For each clause, we introduce integers <span class="math inline">S_i</span>, which has 1 at position <span class="math inline">C_i</span>. For each clause, we introduce integers <span class="math inline">S_i&#39;</span>, which has 2 at position <span class="math inline">C_i</span>.</p>
<p>Consider the following example:</p>
<ul>
<li>$ C_1 = x_1 x_2 x_3$</li>
<li>$ C_2 = x_1 x_2 x_3$</li>
<li>$ C_2 = x_1 x_2 x_3$</li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>C1</th>
<th>C2</th>
<th>C3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>v1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>v1'</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>v2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>v2'</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>v3</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>v3'</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th></th>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>C1</th>
<th>C2</th>
<th>C3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>S1'</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>S2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td>S2'</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr class="odd">
<td>S3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>S3'</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>So we can construct our new integers in polynomial time. We want to show that <span class="math inline">\phi</span> is SAT if and only if <span class="math inline">(v_i, v_i&#39;, s_j, s_j&#39;, t) \in L_{SUB-SUM}</span></p>
<h5 id="section">=&gt;</h5>
<p>Assume <span class="math inline">\phi</span> is in SAT. Let <span class="math inline">x</span> be an SAT assignment. Select the following numbers for the set:</p>
<ul>
<li>if <span class="math inline">x_i = T</span>, select <span class="math inline">v_i</span></li>
<li>if <span class="math inline">x_i = F</span>, select <span class="math inline">v_i&#39;</span></li>
<li>if <span class="math inline">C_i</span> is satisfied by 1 literal, select <span class="math inline">s_i, s_i&#39;</span>, if by 2 select <span class="math inline">s_i&#39;</span>, and if satisfied by 3, selecte <span class="math inline">s_i</span>.</li>
</ul>
<p>So the subset adds up to <span class="math inline">t</span>. There are exactly one of <span class="math inline">v_i</span>, <span class="math inline">v_i&#39;</span> that belongs to <span class="math inline">S</span> for each <span class="math inline">i</span>.</p>
<h5 id="section-1">&lt;=</h5>
<p>Let <span class="math inline">x</span> be the assignment, where if <span class="math inline">v_i \in S</span>, <span class="math inline">x_i = T</span>, and if <span class="math inline">v_i \in S</span>, set <span class="math inline">x_i = F</span>. This implies that <span class="math inline">x</span> is a satisfying assignment.</p>
<h2 id="knapsack">Knapsack</h2>
<h4 id="input-1">Input</h4>
<ul>
<li><span class="math inline">v_1, ..., v_n \in \mathbb N</span>, our values of the items</li>
<li><span class="math inline">v_1, ..., v_n \in \mathbb N</span>, our weights</li>
<li><span class="math inline">W</span>, our capacity.</li>
</ul>
<h4 id="output-1">Output:</h4>
<p><span class="math display">\displaystyle 
\max_{S \subseteq [n]} \sum_{i \in S} v_i : \sum_{i \in S} w_i \leq W
</span></p>
<p>Let the language of the this problem be our <span class="math inline">v_i, w_i, W, K</span> such that there exists <span class="math inline">S \subseteq [n]</span> such that</p>
<p><span class="math display">\displaystyle 
\sum_{i \in S} v_i \geq k
</span></p>
<p><span class="math display">\displaystyle 
\sum_{i \in S} w_i \geq W
</span></p>
<p>Let <span class="math inline">v_i = a_i = w_i</span>, <span class="math inline">W = k = t</span></p>
<p>Then <span class="math inline">\sum_{i \in S} v_i \geq t</span> and <span class="math inline">\sum_{i \in S} w_i \leq t</span>.</p>
      <div class="flex pa4">
              <a href="" class="f5 no-underline black bg-animate hover-bg-black hover-white inline-flex items-center pa3 ba border-box mr4">
          <svg class="w1" data-icon="chevronLeft" viewBox="0 0 32 32" style="fill:currentcolor">
            <title>Prev</title>
            <path d="M20 1 L24 5 L14 16 L24 27 L20 31 L6 16 z"></path>
          </svg>
          <span class="pl1"></span>
        </a>
                     <a href="" class="f5 no-underline black bg-animate hover-bg-black hover-white inline-flex items-center pa3 ba border-box">
          <span class="pr1"></span>
          <svg class="w1" data-icon="chevronRight" viewBox="0 0 32 32" style="fill:currentcolor">
            <title>chevronRight icon</title>
            <path d="M12 1 L26 16 L12 31 L8 27 L18 16 L8 5 z"></path>
          </svg>
        </a>
            </div>
          </div>   
  </body>
</html>
