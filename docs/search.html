<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CSC373</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <link rel="stylesheet" href="https://unpkg.com/tachyons@4.6.1/css/tachyons.min.css" type="text/css" media="screen" charset="utf-8">
        <link rel="stylesheet" href="css/main.css">
              <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" /><script type="text/javascript">window.onload = function(){var mathElements = document.getElementsByClassName("math");
      for (var i=0; i < mathElements.length; i++)
      {
       var texText = mathElements[i].firstChild
       katex.render(texText.data, mathElements[i])
      }}
      </script>
          </head>
  <body>
    <div class="ml4 mt3 pr4 ">
      <header class="w6">
        <div class="w-80-m w-100-ns bb bw2 pb1">
          <span class="f1 baskerville">isthisnagee</span>
        </div>
        <nav class="pv2 f5">
          <ul class="list pl0 pt0">
            <li class="dib">
              <a class="link pointer color-a bb pb0 bw2 space-mono b--gray" href="http://isthisnagee.github.io">isthisnagee</a><span class="f5 space-mono">&nbsp;||&nbsp;</span>
            </li>
            <li class="dib">
              <a class="pointer bb pb0 bw2 link color-a space-mono b--gray" href="index.html">csc373
              </a>
            </li>
          </ul>
        </nav>
              </header>
      <h1 id="search-problems">Search Problems</h1>
      <p>Most of the algorithms we've studied have an exponential number of possible solutions (matching <span class="math inline">n</span> pairs is factorial in size, <span class="math inline">n</span> vertices has <span class="math inline">n^{n-2}</span> spanning trees), but we've taken advantage of structure and assumptions to eliminate large classes of potential solutions, giving us polynomial time algorithms in the worst case. We'll look at some problems that we have yet to solve in efficient time.</p>
      <p>But first, let's define some things:</p>
      <h3 id="search-problem">Search Problem</h3>
      <p>A search problem is specified by an algorithm <span class="math inline">C</span> that takes two inputs:</p>
      <ul>
      <li>An <em>instance</em> <span class="math inline">I</span> and a proposed <em>solution</em> <span class="math inline">S</span>.</li>
      <li><span class="math inline">C</span> runs in time polynomial to <span class="math inline">|I|</span>.</li>
      </ul>
      <p>We say <span class="math inline">S</span> is a solution to <span class="math inline">I</span> iff <span class="math inline">C(I,S) =</span> <code>true</code></p>
      <h2 id="satisfiability">Satisfiability</h2>
      <p>Satisfiability (<code>SAT</code>) has a boolean formula in CNF as its <em>instance</em>. A <em>solution</em> to the instance is a boolean assignment function that takes each variable <span class="math inline">v_i</span> to <code>true</code> or <code>false</code>. The <code>SAT</code> problem is the following</p>
      <blockquote>
      <p>Given a Boolean formula in CNF, either find a satisfying truth assignment or report that none exists.</p>
      </blockquote>
      <h3 id="horn-and-2sat">Horn and 2SAT</h3>
      <p>A <strong>Horn Formula</strong> is a boolean formula where all clauses contain at most one positive literal, and a greedy algorithm can be used to find the satisfying truth assignment.</p>
      <p>If we allow two literals, then we can use graph theory, and <code>SAT</code> can be solved in linear time (DPV excersize 3.28).</p>
      <p>If we allow three literals, we have no fast solution ðŸ˜¢. Thi is called the <code>3SAT</code> problem.</p>
      <h2 id="traveling-salesman">Traveling Salesman</h2>
      <p>This (quite famous) problem gives use <span class="math inline">n</span> vertices with <span class="math inline">\frac{n(n-1)}{2}</span> distances between them, and a budget <span class="math inline">b</span>, and we are asked to solve for a permutation <span class="math inline">\pi</span> of the vertices such that</p>
      <p><span class="math display">\displaystyle 
      \sum_{i=1}^n d_{\pi(i), \pi(i+1\mod n-1)} \leq b
      </span></p>
      <p>TSP is a <em>search problem</em>:</p>
      <ul>
      <li>Instance: The vertices, distances, and budget</li>
      <li>Solution: the permutation <span class="math inline">\pi</span> (or nothing)</li>
      </ul>
      <p>The problem here is finding the <em>optimum</em> solution. If we are given a solution <span class="math inline">S</span> to an instance <span class="math inline">I</span>, how do we know if <span class="math inline">S</span> is the best solution?</p>
      <div class="flex pa4">
                   </div>
          </div>   
  </body>
</html>
